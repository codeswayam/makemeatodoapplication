<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pure-Frontend ToDo App</title>
    <style>
        /* Basic resets and global styling */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4; /* Light mode default background */
            color: #333; /* Light mode default text color */
            transition: background-color 0.3s, color 0.3s; /* Smooth transition for dark/light mode */
            display: flex;
            justify-content: center;
            min-height: 100vh; /* Full viewport height */
            box-sizing: border-box;
        }

        /* Dark mode specific styles */
        body.dark-mode {
            background-color: #2c2c2c;
            color: #e0e0e0;
        }

        /* Main container for the app */
        .container {
            background-color: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            width: 100%;
            margin-top: 20px;
            box-sizing: border-box;
        }

        /* Dark mode container styling */
        body.dark-mode .container {
            background-color: #3a3a3a;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        /* Header styling */
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 25px;
            font-size: 2.2rem;
        }

        /* Dark mode header styling */
        body.dark-mode h1 {
            color: #e0e0e0;
        }

        /* Dark mode toggle button */
        #darkModeToggle {
            display: block;
            margin: 0 auto 25px auto;
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            background-color: #6c757d; /* Grey button */
            color: white;
            font-size: 0.9rem;
            transition: background-color 0.2s;
            outline: none;
        }

        #darkModeToggle:hover {
            background-color: #5a6268;
        }

        /* Input area for new tasks */
        .task-input {
            display: flex;
            gap: 10px; /* Space between input and button */
            margin-bottom: 25px;
        }

        #newTaskInput {
            flex-grow: 1;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s;
        }

        #newTaskInput:focus {
            border-color: #007bff;
        }

        body.dark-mode #newTaskInput {
            background-color: #4a4a4a;
            color: #e0e0e0;
            border-color: #666;
        }

        body.dark-mode #newTaskInput:focus {
            border-color: #6daffb;
        }

        #addTaskButton {
            padding: 12px 20px;
            background-color: #007bff; /* Blue button */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
            outline: none;
        }

        #addTaskButton:hover {
            background-color: #0056b3;
        }

        /* Task list styling */
        #taskList {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        /* Individual task item styling */
        .task-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #eee;
        }

        /* Dark mode task item border */
        body.dark-mode .task-item {
            border-bottom: 1px solid #555;
        }

        .task-item:last-child {
            border-bottom: none; /* No border for the last item */
        }

        /* Completed task text styling */
        .task-item.completed span {
            text-decoration: line-through;
            color: #888;
        }

        /* Dark mode completed task text styling */
        body.dark-mode .task-item.completed span {
            color: #aaa;
        }

        /* Task text span */
        .task-item span {
            flex-grow: 1;
            margin-right: 15px;
            word-break: break-word; /* Prevents long words from overflowing */
            font-size: 1.05rem;
        }
        
        /* Action buttons container */
        .task-item .actions {
            display: flex;
            gap: 5px; /* Space between action buttons */
        }

        /* Common button styles within task items */
        .task-item .actions button {
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background-color 0.2s, opacity 0.2s;
            outline: none;
            white-space: nowrap; /* Prevent button text from wrapping */
        }

        /* Complete/Uncomplete button */
        .task-item .actions button.complete {
            background-color: #28a745; /* Green */
            color: white;
        }

        .task-item .actions button.complete:hover {
            background-color: #218838;
        }

        .task-item .actions button.uncomplete {
            background-color: #6c757d; /* Grey */
            color: white;
        }

        .task-item .actions button.uncomplete:hover {
            background-color: #5a6268;
        }

        /* Edit button */
        .task-item .actions button.edit {
            background-color: #ffc107; /* Yellow/Orange */
            color: #333;
        }

        .task-item .actions button.edit:hover {
            background-color: #e0a800;
        }

        /* Delete button */
        .task-item .actions button.delete {
            background-color: #dc3545; /* Red */
            color: white;
        }

        .task-item .actions button.delete:hover {
            background-color: #c82333;
        }

        /* Styling for the input field when editing a task */
        .task-item input[type="text"] {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 5px;
            font-size: 1rem;
            outline: none;
        }

        /* Dark mode styling for edit input */
        body.dark-mode .task-item input[type="text"] {
            background-color: #555;
            color: #e0e0e0;
            border-color: #777;
        }

        /* Save button in edit mode */
        .task-item .actions button.save {
            background-color: #007bff; /* Blue */
            color: white;
        }

        .task-item .actions button.save:hover {
            background-color: #0056b3;
        }

        /* Cancel button in edit mode */
        .task-item .actions button.cancel {
            background-color: #6c757d; /* Grey */
            color: white;
        }

        .task-item .actions button.cancel:hover {
            background-color: #5a6268;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Pure-Frontend ToDo App</h1>
        <button id="darkModeToggle">Toggle Dark Mode</button>

        <div class="task-input">
            <input type="text" id="newTaskInput" placeholder="Add a new task...">
            <button id="addTaskButton">Add Task</button>
        </div>

        <ul id="taskList">
            <!-- Tasks will be dynamically rendered here by JavaScript -->
        </ul>
    </div>

    <script>
        // Array to store task objects. Each task has an id, text, and completed status.
        let tasks = [];

        // --- DOM Element References --- 
        const newTaskInput = document.getElementById('newTaskInput');
        const addTaskButton = document.getElementById('addTaskButton');
        const taskList = document.getElementById('taskList');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const body = document.body;

        // --- LocalStorage Functions --- 
        // Loads tasks from localStorage when the app starts
        function loadTasks() {
            const storedTasks = localStorage.getItem('tasks');
            if (storedTasks) {
                tasks = JSON.parse(storedTasks); // Parse JSON string back into an array
            } else {
                tasks = []; // Initialize as empty array if no tasks are stored
            }
        }

        // Saves the current tasks array to localStorage
        function saveTasks() {
            localStorage.setItem('tasks', JSON.stringify(tasks)); // Convert array to JSON string for storage
        }

        // --- UI Rendering --- 
        // Renders all tasks from the 'tasks' array to the UI
        function renderTasks() {
            taskList.innerHTML = ''; // Clear the current list to re-render

            // Sort tasks to show incomplete first, then completed, both by creation date (ID) descending (newest first)
            const sortedTasks = [...tasks].sort((a, b) => {
                if (a.completed === b.completed) {
                    return b.id - a.id; // Newest first for tasks with same completion status
                }
                return a.completed ? 1 : -1; // Incomplete tasks first (false=0, true=1; so false comes before true)
            });

            sortedTasks.forEach(task => {
                const li = document.createElement('li');
                // Add 'task-item' class and 'completed' class if task is completed
                li.className = `task-item ${task.completed ? 'completed' : ''}`;
                li.dataset.id = task.id; // Store task ID on the list item for easy access

                const taskTextSpan = document.createElement('span');
                taskTextSpan.textContent = task.text;
                li.appendChild(taskTextSpan);

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'actions';

                // Complete/Uncomplete Button
                const completeButton = document.createElement('button');
                completeButton.textContent = task.completed ? 'Uncomplete' : 'Complete';
                // Set class for different styling based on completion status
                completeButton.className = task.completed ? 'uncomplete' : 'complete'; 
                completeButton.addEventListener('click', () => toggleCompleteTask(task.id));
                actionsDiv.appendChild(completeButton);

                // Edit Button
                const editButton = document.createElement('button');
                editButton.textContent = 'Edit';
                editButton.className = 'edit';
                editButton.addEventListener('click', () => editTask(task.id, li, taskTextSpan));
                actionsDiv.appendChild(editButton);

                // Delete Button
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.className = 'delete';
                deleteButton.addEventListener('click', () => deleteTask(task.id));
                actionsDiv.appendChild(deleteButton);

                li.appendChild(actionsDiv);
                taskList.appendChild(li);
            });
        }

        // --- Task CRUD Operations --- 
        // Adds a new task to the list
        function addTask() {
            const text = newTaskInput.value.trim();
            if (text === '') {
                alert('Task description cannot be empty!'); // User feedback for empty input
                return;
            }

            const newTask = {
                id: Date.now(), // Unique ID using timestamp (milliseconds since epoch)
                text: text,
                completed: false
            };
            tasks.unshift(newTask); // Add new task to the beginning of the array
            saveTasks(); // Persist tasks to localStorage
            renderTasks(); // Update the UI
            newTaskInput.value = ''; // Clear the input field
        }

        // Toggles the 'completed' status of a task
        function toggleCompleteTask(id) {
            tasks = tasks.map(task =>
                task.id === id ? { ...task, completed: !task.completed } : task
            );
            saveTasks();
            renderTasks();
        }

        // Deletes a task from the list
        function deleteTask(id) {
            // Confirmation dialog before deleting
            if (confirm('Are you sure you want to delete this task?')) {
                tasks = tasks.filter(task => task.id !== id);
                saveTasks();
                renderTasks();
            }
        }

        // Enables editing for a task item
        function editTask(id, listItem, currentSpan) {
            const task = tasks.find(t => t.id === id);
            if (!task) return; // Task not found

            // Create an input field pre-filled with the current task text
            const editInput = document.createElement('input');
            editInput.type = 'text';
            editInput.value = task.text;
            editInput.classList.add('edit-input');

            // Create a save button for the edited task
            const saveButton = document.createElement('button');
            saveButton.textContent = 'Save';
            saveButton.className = 'save';
            saveButton.addEventListener('click', () => {
                const newText = editInput.value.trim();
                if (newText !== '') { // Ensure new text is not empty
                    tasks = tasks.map(t =>
                        t.id === id ? { ...t, text: newText } : t
                    );
                    saveTasks();
                } else {
                    alert('Task description cannot be empty!');
                }
                renderTasks(); // Re-render the list to show updated task or revert if cancelled/empty
            });

            // Create a cancel button for the edit operation
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.className = 'cancel';
            cancelButton.addEventListener('click', () => {
                renderTasks(); // Re-render to revert the task item to its original display
            });

            // Temporarily replace the task text and action buttons with the edit input and save/cancel buttons
            listItem.innerHTML = ''; // Clear existing content of the li
            listItem.appendChild(editInput);
            const editActionsDiv = document.createElement('div');
            editActionsDiv.className = 'actions'; // Use the actions class for styling
            editActionsDiv.appendChild(saveButton);
            editActionsDiv.appendChild(cancelButton);
            listItem.appendChild(editActionsDiv);

            editInput.focus(); // Automatically focus on the input field
            // Allow saving by pressing Enter key in the edit input
            editInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveButton.click(); 
                }
            });
        }

        // --- Dark Mode Functionality --- 
        // Loads dark mode preference from localStorage on app load
        function loadDarkModePreference() {
            // Check if 'darkMode' item exists and is 'true'
            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            if (isDarkMode) {
                body.classList.add('dark-mode'); // Apply dark mode class to body
            }
        }

        // Toggles dark mode on/off
        function toggleDarkMode() {
            body.classList.toggle('dark-mode'); // Add or remove 'dark-mode' class
            const isDarkMode = body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDarkMode); // Persist preference to localStorage
        }

        // --- Event Listeners --- 
        // Event listener for adding a task when the button is clicked
        addTaskButton.addEventListener('click', addTask);

        // Event listener for adding a task when 'Enter' key is pressed in the input field
        newTaskInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addTask();
            }
        });

        // Event listener for the dark mode toggle button
        darkModeToggle.addEventListener('click', toggleDarkMode);

        // --- Initialization --- 
        // Ensures DOM is fully loaded before running initial setup
        document.addEventListener('DOMContentLoaded', () => {
            loadDarkModePreference(); // Load dark mode setting first
            loadTasks(); // Load existing tasks
            renderTasks(); // Display tasks on the UI
        });
    </script>
</body>
</html>